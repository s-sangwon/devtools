-- DAY8_DDL_DML2.sql
-- DDL 구문과 DML 구문

-- 서브쿼리를 사용해서 새 테이블을 만들 수 있음
-- SELECT 실행 결과를 테이블에 저장한다는 의미가 됨

CREATE TABLE EMP_DEPT90
AS
SELECT * FROM EMPLOYEE
WHERE DEPT_ID = '90';

SELECT * FROM EMP_DEPT90;

-- 테이블 구조 확인 : DESC[RIBE] 테이블명;
DESCRIBE EMP_DEPT90;
DESC EMP_DEPT90;

-- 준비된 SQL 스크립트 파일 실행 명령어 : START 경로명\\파일명.sql
-- START => 축약형 : @ 경로명\\파일명.sql

-- 서브쿼리를 이용해서 기존의 테이블을 복사한 경우,
-- 컬럼명, 자료형, NOT NULL 제약조건만 그대로 복사됨
-- 나머지 제약조건들과 DEFAULT 는 복사 안 됨

-- 기존 테이블 복사본 만들 때도 이용할 수 있음
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;
DESC EMP_COPY;

-- 실습 1.
-- 사번, 이름, 급여, 직급명, 부서명, 근무지역명, 소속국가명 조회한 결과를
-- EMP_LIST 테이블에 저장함. (단, 직원 전체 정보여야 함)
CREATE TABLE EMP_LIST
AS 
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, 
        DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID)
LEFT JOIN COUNTRY USING (COUNTRY_ID);

SELECT * FROM EMP_LIST;  -- 확인
DESC EMP_LIST;  -- 테이블 구조 확인

-- 실습 2.
-- EMPLOYEE 테이블에서 남자 직원들의 정보만 조회해서
-- EMP_MAN 테이블에 저장함
CREATE TABLE EMP_MAN
AS
SELECT * FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) IN ('1', '3');

SELECT * FROM EMP_MAN;

-- 여자 직원들의 정보만 골라내서 EMP_FEMAIL 테이블에 저장함
CREATE TABLE EMP_FEMAIL
AS
SELECT * FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) IN ('2', '4');

SELECT * FROM EMP_FEMAIL;

-- 실습 3. 
-- 부서별로 정렬된 모든 직원의 명단을 PART_LIST 테이블에 저장함
-- DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID 로 조회함
-- 생성된 테이블의 각 컬럼에 설명(COMMENT) 달기
-- 부서명, 직급명, 이름, 사번

CREATE TABLE PART_LIST
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY DEPT_NAME;

SELECT * FROM PART_LIST;

COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '이름';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';

DESC PART_LIST;

-- 서브쿼리로 새 테이블 만들 때, 컬럼명 바꿀 수 있음
-- 주의사항 : 서브쿼리 SELECT 절의 컬럼 갯수와 바꿀 컬럼명의 갯수가 동일해야 함
/*
CREATE TABLE 테이블명 (바꿀컬럼명, ......)
AS 서브쿼리;
*/

CREATE TABLE PART_LIST2 (DNAME, JTITLE, ENAME, EID)
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY DEPT_NAME;

DESC PART_LIST2;

-- 에러 주의 : 
CREATE TABLE PART_LIST3 (DNAME, JTITLE, ENAME)  -- 바꿀 컬럼명 : 3개
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID  -- 컬럼 : 4개
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY DEPT_NAME;

-- 해결방법 : 일부 컬럼명만 바꾸려면, SELECT 절에 별칭(ALIAS) 사용함
CREATE TABLE PART_LIST3
AS
SELECT DEPT_NAME DNAME, JOB_TITLE JTITLE, EMP_NAME ENAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY DEPT_NAME;

DESC PART_LIST3;

-- 실습 : 제약조건이 설정된 테이블 만들기
-- 테이블명 : PHONEBOOK
-- 컬럼명 :  ID  CHAR(3) 기본키(저장이름 : PK_PBID)
--         PNAME      VARCHAR2(20)  널 사용못함.
--                                 (NN_PBNAME) 
--         PHONE      VARCHAR2(15)  널 사용못함
--                                 (NN_PBPHONE)
--                                 중복값 입력못함
--                                 (UN_PBPHONE)
--         ADDRESS    VARCHAR2(100) 기본값 지정함
--                                 '서울시 구로구'

-- NOT NULL을 제외하고, 모두 테이블 레벨에서 지정함.

CREATE TABLE PHONEBOOK (
       ID    CHAR(3),
       PNAME VARCHAR2(20) CONSTRAINT NN_PBNAME NOT NULL,
       PHONE VARCHAR2(15) CONSTRAINT NN_PBPHONE NOT NULL,
       ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
	   -- 테이블레벨
       CONSTRAINT PK_PBID PRIMARY KEY (ID),
       CONSTRAINT UN_PBPHONE UNIQUE (PHONE)       
);

INSERT INTO PHONEBOOK 
VALUES ('A01', '홍길동', '010-1234-5678', DEFAULT);

SELECT * FROM PHONEBOOK;

-- 서브쿼리로 새 테이블 만들 때, 컬럼명 바꾸면서 제약조건도 추가할 수 있음
-- FOREIGN KEY 제약조건은 추가할 수 없음
-- 주의사항 : 서브쿼리의 결과 데이터와 제약조건이 맞아야 추가할 수 있음
CREATE TABLE TBL_SUBQUERY3 (
    EID PRIMARY KEY, -- OK
    ENAME,
    SAL CHECK (SAL > 2000000),  -- ERROR, 조건에 맞지 않는 값이 기록되어 있음
    DNAME,
    JTITLE NOT NULL  -- ERROR, NULL 이 포함되어 있음
)
AS
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, 
        -- JTITLE NOT NULL 해결 2
        NVL(JOB_TITLE, '미지정')
        JOB_TITLE
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
-- CHECK (SAL > 2000000) 해결
WHERE SALARY > 2000000
-- JTITLE NOT NULL 해결 1
-- AND JOB_TITLE IS NOT NULL;

-- 테이블 제거 구문 *********************
-- DROP TABLE 제거할테이블명 [CASCADE CONSTRAINTS];
-- 제약조건을 가진 테이블은 삭제할 수 없음
-- 제약조건도 함께 삭제하면 됨
DROP TABLE EMPLOYEE;  -- 제약조건 있는 테이블임. 삭제 못함 : ERROR
DROP TABLE TBL_SUBQUERY3 CASCADE CONSTRAINTS;

-- 데이터 딕셔너리 (데이터 사전) ********************************
-- 사용자가 생성한 
-- 모든 데이터베이스 객체 정보를 테이블 형태로 자동 저장관리하는 영역
-- 조회만 할 수 있고, 수정 못 함
-- DBMS 시스템에 의해 자동 관리되고 있음
-- 예를 들면, 사용자가 만든 테이블, 사용자가 설정한 제약조건들도 자동 저장 관리됨

-- 제약조건 관련 딕셔너리 : USER_CONSTRAINTS
DESC USER_CONSTRAINTS;

-- 제약조건 딕셔너리 조회
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, 
        TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'PHONEBOOK';

-- CONSTRINT_TYPE 
-- P : PRIMARY KEY
-- U : UNIQUE
-- R : FOREIGN KEY
-- C : CHECK, NOT NULL

-- 사용자가 소유한 테이블 객체 정보 : USER_TABLES
SELECT * FROM USER_TABLES;

-- 사용자가 만든 뷰 객체 정보 : USER_VIEWS
SELECT * FROM USER_VIEWS;

-- 사용자가 만든 시퀀스 객체 정보 : USER_SEQUENCES
SELECT * FROM USER_SEQUENCES;

-- 사용자가 만든 인덱스 객체 정보 : USER_INDEXES
SELECT * FROM USER_INDEXES;

-- 서브쿼리를 가지고 테이블을 만들 때, 데이터는 제외하고 구조만 복사할 수 있음
-- WHERE 절에 1 = 0 표기하면 됨
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT
WHERE 1 = 0;

SELECT * FROM DEPT_COPY;
DESC DEPT_COPY;

-- DDL (Data Definition Language : 데이터 정의어)
-- CREATE, ALTER, DROP
-- 데이터베이스 객체를 만들고, 수정하고, 삭제하는 구문임
-- 테이블 : CREATE TABLE, ALTER TABLE, DROP TABLE
-- 뷰 : CREATE VIEW, DROP VIEW
-- 시퀀스 : CREATE SEQUENCE, ALTER SEQUENCE, DROP SEQUENCE
-- 인덱스 : CREATE INDEX, DROP INDEX

-- 테이블 수정 (ALTER TABLE) ************************
-- 컬럼 추가/삭제, 제약조건 추가/삭제
-- 컬럼 자료형 변경 (자료형 크기 변경 포함)
-- 테이블명, 컬럼명, 제약조건 이름 변경
-- DEFAULT 값 변경

-- 테스트용 테이블 확인
DROP TABLE DEPT_COPY;

CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

-- 컬럼 추가
-- 테이블 생성시 컬럼 작성과 동일하게 작성하면 됨
ALTER TABLE DEPT_COPY
ADD (LNAME  VARCHAR2(40));

-- 확인
SELECT * FROM DEPT_COPY;
DESC DEPT_COPY;

-- 컬럼 추가시 DEFAULT 값도 같이 지정할 수 있음
ALTER TABLE DEPT_COPY
ADD (CNAME VARCHAR2(30) DEFAULT '한국');

SELECT * FROM DEPT_COPY;

-- 제약조건 추가
CREATE TABLE EMP2
AS
SELECT * FROM EMPLOYEE;

SELECT * FROM EMP2;
DESC EMP2;

-- NOT NULL 은 ADD 로 추가할 수 없음
-- MODIFY 로 NULLABLE 상태를 YES 에서 NO 로 변경해야 함
ALTER TABLE EMP2
ADD NOT NULL (HIRE_DATE);  -- ERROR

ALTER TABLE EMP2
MODIFY (HIRE_DATE NOT NULL);

DESC EMP2;

ALTER TABLE EMP2
ADD PRIMARY KEY (EMP_ID);

ALTER TABLE EMP2
ADD CONSTRAINT E2_UNENO UNIQUE (EMP_NO);

-- 컬럼 자료형 변경
CREATE TABLE EMP3
AS
SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE;

SELECT * FROM EMP3;
DESC EMP3;

ALTER TABLE EMP3
MODIFY (EMP_ID VARCHAR2(5), 
         EMP_NAME CHAR(20));

DESC EMP3;

-- DEFAULT 값 변경
CREATE TABLE EMP4 (
    EMP_ID  CHAR(3),
    EMP_NAME VARCHAR2(20),
    ADDR1  VARCHAR2(20)  DEFAULT '서울',
    ADDR2  VARCHAR2(100)
);

INSERT INTO EMP4 
VALUES ('A10', '임태희', DEFAULT, '청담동');

INSERT INTO EMP4 
VALUES ('B10', '이병언', DEFAULT, '역삼동');

SELECT * FROM EMP4;

ALTER TABLE EMP4
MODIFY (ADDR1 DEFAULT '경기');

INSERT INTO EMP4 
VALUES ('C10', '임승우', DEFAULT, '정자동');

SELECT * FROM EMP4;

-- 컬럼 삭제
DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
DROP COLUMN CNAME;  -- 컬럼 1개 삭제

DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
DROP (LOC_ID, LNAME);  -- 컬럼 여러 개 삭제

DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
DROP (DEPT_ID, DEPT_NAME);  -- ERROR
-- 데이터베이스에서 테이블은 최소 1개의 컬럼을 가지고 있어야 함
-- 컬럼이 없는 테이블은 존재할 수 없음 : 모든 컬럼을 삭제할 수 없음
-- 테이블 생성시에도 마찬가지임
CREATE TABLE TTT ();

-- 제약조건을 가진 컬럼은 그냥 삭제할 수 없음
-- FOREIGN KEY 제약조건으로 참조되고 있는 컬럼(부모키)도 그냥 삭제할 수 없음
-- 해결 : 컬럼과 제약조건을 함께 삭제(CASCADE)하면 됨
-- CASCADE CONSTRAINTS 를 구문 뒤에 표기함

ALTER TABLE DEPARTMENT
DROP (DEPT_ID);  -- ERROR

CREATE TABLE TB1 (
    PK  NUMBER  PRIMARY KEY,  -- 부모키
    FK  NUMBER  REFERENCES TB1,  -- 자식레코드
    COL1   NUMBER,
    CHECK (COL1 > 0 AND PK > 0)
);

ALTER TABLE TB1
DROP (PK);  -- ERROR

ALTER TABLE TB1
DROP (COL1); -- ERROR

-- 제약조건도 함께 삭제하면 됨
ALTER TABLE TB1
DROP (PK) CASCADE CONSTRAINTS;

DESC TB1;

ALTER TABLE TB1
DROP (COL1) CASCADE CONSTRAINTS;

DESC TB1;

-- 제약조건 삭제
SELECT * FROM CONSTRAINT_EMP;
DESC CONSTRAINT_EMP;

-- 제약조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, 
        TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONSTRAINT_EMP';

-- 테이블 이름 바꾸기
RENAME CONSTRAINT_EMP TO CONST_EMP;

-- 제약조건 여러 개 삭제
ALTER TABLE CONST_EMP
DROP CONSTRAINT FKDID
DROP CONSTRAINT FKJID
DROP CONSTRAINT FKMID;

-- 제약조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, 
        TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONST_EMP';

-- NOT NULL 제약조건은 삭제가 아니라 변경임
-- NOT NULL 을 NULL 로 바꿈
ALTER TABLE CONST_EMP
MODIFY (ENAME NULL, ENO NULL);

-- 제약조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, 
        TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONST_EMP';

-- USER_CONSTRAINTS 딕셔너리 : 컬럼 정보 없음
-- 컬럼별 제약조건을 관리하는 딕셔너리 : USER_CONS_COLUMNS
DESC USER_CONS_COLUMNS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME,
        DELETE_RULE, SEARCH_CONDITION
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING (CONSTRAINT_NAME, TABLE_NAME)
WHERE TABLE_NAME = 'CONST_EMP';

-- 제약조건 삭제 2
ALTER TABLE CONST_EMP
DROP PRIMARY KEY;

ALTER TABLE CONST_EMP
DROP UNIQUE (ENO);

-- 이름 바꾸기 : 테이블명, 컬럼명, 제약조건이름
-- 컬럼명 바꾸기
DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
RENAME COLUMN DEPT_ID TO DID;

DESC DEPT_COPY;

-- 제약조건 이름 바꾸기
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME,
        DELETE_RULE, SEARCH_CONDITION
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING (CONSTRAINT_NAME, TABLE_NAME)
WHERE TABLE_NAME = 'CONST_EMP';

ALTER TABLE CONST_EMP
RENAME CONSTRAINT CHK TO MRG_CHK;

-- 테이블명 바꾸기
ALTER TABLE DEPT_COPY RENAME TO DPCOPY;
RENAME DPCOPY TO DEPT_COPY;

-- 테이블 삭제하기 *****************
DROP TABLE DEPT_COPY;

DROP TABLE DEPARTMENT;  -- ERROR
DROP TABLE DEPARTMENT CASCADE CONSTRAINTS;

ROLLBACK;  -- DDL 구문은 복구 안 됨, DML 구문만 복구됨

