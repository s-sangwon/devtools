-- DAY8_DDL_DML2.sql
-- DDL 구문과 DML 구문

-- 서브쿼리를 사용해서 새 테이블을 만들 수 있음
-- SELECT 실행 결과를 테이블에 저장한다는 의미가 됨

CREATE TABLE EMP_DEPT90
AS
SELECT * FROM EMPLOYEE
WHERE DEPT_ID = '90';

SELECT * FROM EMP_DEPT90;

-- 테이블 구조 확인 : DESC[RIBE] 테이블명

DESCRIBE EMPLOYEE;

-- 준비된 SQL 스크립트 파일 실행 명령어 : START 경로명\\파일명.sql
-- START => 축약형 : @ 경로명\\파일명.sql

-- 서브쿼리를 이용해서 기존의 테이블을 복사한 경우,
-- 컬럼명, 자료형, NOT NULL 제약조건만 그대로 복사됨
-- 나머지 제약조건들과 DEFAULT 는 복사 안 됨

-- 기존 테이블 복사본 만들 때도 이용할 수 있음
CREATE TABLE EMP_COPY
AS 
SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;
DESC EMP_COPY;

-- 1.
CREATE TABLE EMP_LIST
AS
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN LOCATION ON LOC_ID = LOCATION_ID
LEFT JOIN COUNTRY USING (COUNTRY_ID);

SELECT * FROM EMP_LIST; -- 확인
DESC EMP_LIST; -- 테이블 구조 확인



-- 실습 2
CREATE TABLE EMP_MAN
AS
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = 1;

CREATE TABLE EMP_FEMAIL
AS
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = 2;

SELECT * FROM EMP_FEMAIL; -- 확인
SELECT * FROM EMP_MAN;
DESC EMP_FEMAIL;

-- 실습 3.
CREATE TABLE PART_LIST
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY 1;

COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '이름';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';

SELECT * FROM PART_LIST;
DESC PART_LIST;

-- 서브쿼리로 새 테이블 만들 때, 컬럼명 바꿀 수 있음
-- 주의사항 : 서브쿼리 SELECT 절의 컬럼 갯수와 바꿀 컬럼명의 갯수가 동일해야 함
/*
CREATE TABLE 테이블명 (바꿀컬럼명, ...)
AS 서브쿼리;
*/

CREATE TABLE PART_LIST2 (DNAME, JTITLE, ENAME, EID)
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY 1;

DESC PART_LIST2


-- 에러 주의 :

CREATE TABLE PART_LIST3 (DNAME, JTITLE, ENAME) -- 바꿀 컬럼3개
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID -- 컬럼 4개
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY 1;

-- 해결방법 : 일부 컬럼명만 바꿀려면 SELECT 절에 별칭(ALIAS) 사용
CREATE TABLE PART_LIST3 -- 바꿀 컬럼3개
AS
SELECT DEPT_NAME DNAME, JOB_TITLE JTITLE, EMP_NAME ENAME, EMP_ID -- 컬럼 4개
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
ORDER BY 1;


-- 실습 테이블 만들기

CREATE TABLE PHONEBOOK (
    ID CHAR(3),
    PNAME   VARCHAR2(20) CONSTRAINT NN_PBNAME NOT NULL,
    PHONE   VARCHAR2(15) CONSTRAINT NN_PBHONE NOT NULL,
    ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
    CONSTRAINT UN_PBPHONE  UNIQUE (PHONE),
    CONSTRAINT PK_PBID  PRIMARY KEY (ID)
);


-- 서브쿼리로 새 테이블 만들 때, 컬럼명 바꾸면서 제약조건도 추가할 수 있다
-- FOREIGN KEY 제약조건은 추가할 수 없음
-- 주의사함 : 서브쿼리의 겨로가 데이터와 계약조건이 맞아야 추가할 수 있음
CREATE TABLE TBL_SUBQUERY3(
    EID PRIMARY KEY, -- OK
    ENAME,
    SAL CHECK (SAL > 2000000),
    DNAME,
    JTITLE NOT NULL -- ERROR, NULL 이 포함되어 있음
)
AS
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
        --NVL(JOB_TITLE, '미지정')
FROM EMPLOYEE
LEFT JOIN JOB USING(JOB_ID)
LEFT JOIN DEPARTMENT USING(DEPT_ID)
WHERE SALARY > 2000000
AND JOB_TITLE IS NOT NULL;

-- 테이블 제거 구문 *********
-- DROP TABLE 제거할테이블명 [CASCADE CONTRAINTS];
-- 제약조건을 가진 테이블은 삭제할 수 없음
-- 제약조건도 함께 삭제하면 됨

DROP TABLE EMPLOYEE; -- 제약조건 있는 테이블임. 삭제 못함 : ERROR
DROP TABLE TBL_SUBQUERY3 CASCADE CONSTRAINTS;


-- 데이터 딕셔너리 (데이터 사전)  ****************
-- 사용자가 생성한
-- 모든 데이터베이스 객체 정보를 테이블 형태로 자동 저장관리하는 영역
-- 조회만 할 수 있고, 수정 못 함
-- DBMS 시스템에 의해 자동 관리되고 있음
-- 예를 들면, 사용자가 만든 테이블, 사용자가 설정한 제약조건들도 자동 저장 관리됨

-- 제약조건 관련 딕셔너리 : USER_CONSTRAINTS

DESC USER_CONSTRAINTS;

-- 제약조건 딕셔너리 조회
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'PHONEBOOK';

-- CONSTRAINT_TYPE
-- P : PRIMARY KEY
-- U : UNIQUE
-- R ; FOREIGN KEY
-- C : CHECK, NOT NULL

-- 사용자가 소유한 테이블 객체 정보 : USER_TABLES
SELECT * FROM USER_TABLES;

--사용자가 맏는 뷰 객체 정보 : USER_VIEWS
SELECT * FROM USER_VIEWS;

-- 사용자가 만든 시퀀스 객체 정보 : USER_SEQUENCES
SELECT * FROM USER_SEQUENCES;

-- 사용자가 만든 인덱스 객체 정보 : USER_INDEXES
SELECT * FROM USER_INDEXES;

-- 서브쿼리를 가지고 테이블을 만들 때, 데이터는 제외하고 구조만 복사할 수 있음
-- WHERE 절에 1 = 0 표기하면 됨
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT
WHERE 1 = 0;

-- DDL (Data Definition Language : 데이터 정의어)
-- CREATE, ALTER, DROP
-- 데이터베이스 객체를 만들고, 수정하고, 삭제하는 구문임

-- 테이블 : CREATE TABLE, ALTER TABLE, DROP TABLE
-- 뷰 : CREATE VIEW, DROP VIEW
-- 시퀀스 : CREATE SEQUENCE, ALTER SEQUENCE, DROP SEQUENCE
-- 인덱스 : CREATE INDEX, DROP INDEX

-- 테이블 수정 (ALTER TABLE)
-- 컬럼 추가/삭제, 제약조건 추가/삭제
-- 컬럼 자료형 변경 (자료형 크기 변경 포함)
-- 테이블명, 컬럼명, 제약조건 이름 변경
-- DEFAULT 값 변경

-- 테스트용 테이블 확인
DROP TABLE DEPT_COPY;

CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

-- 컬럼 추가
-- 테이블 생성시 컬럼 작성과 동일하게 작성하면 됨

ALTER TABLE DEPT_COPY
ADD (LNAME VARCHAR2(40));

-- 확인
SELECT * FROM DEPT_COPY;
DESC DEPT_COPY;

-- 컬럼 추가시 DEFAULT 값도 같이 지정할 수 있음
ALTER TABLE DEPT_COPY
ADD (CNAME VARCHAR2(30) DEFAULT '한국');

SELECT * FROM DEPT_COPY;

-- 제약조건 추가
CREATE TABLE EMP2 
AS
SELECT * FROM EMPLOYEE;

SELECT * FROM EMP2;
DESC EMP2;

-- NOT NULL 은 ADD 로 추가할 수 없음
-- MODIFY 로 NULLABLE 상태를 YES에서 NO로 변경해야 함
ALTER TABLE EMP2
MODIFY (HIRE_DATE NOT NULL);

ALTER TABLE EMP2
ADD (PRIMARY KEY(EMP_ID));

ALTER TABLE EMP2
ADD CONSTRAINT E2_UNENO UNIQUE (EMP_NO);

-- 컬럼 자료형 변경
CREATE TABLE EMP3
AS
SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE;

SELECT * FROM EMP3;
DESC EMP3;

ALTER TABLE EMP3
MODIFY (EMP_ID VARCHAR2(5), EMP_NAME CHAR(20));

DESC EMP3;


-- DEFAULT 값 변경
CREATE TABLE EMP4 (
    EMP_ID  CHAR(3),
    EMP_NAME    VARCHAR2(20),
    ADDR1   VARCHAR2(20)    DEFAULT '서울',
    ADDR2   VARCHAR2(100) 
);

INSERT INTO EMP4 VALUES ('A10', '임태희', DEFAULT, '청담동');

INSERT INTO EMP4 VALUES ('B10', '이병언', DEFAULT, '역삼동');

SELECT * FROM EMP4;

ALTER TABLE EMP4
MODIFY (ADDR1 DEFAULT '경기');

INSERT INTO EMP4 VALUES ('C10', '임승우', DEFAULT, '정자동');

-- 컬럼 삭제

DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
DROP COLUMN CNAME;

ALTER TABLE DEPT_COPY
DROP (LOC_ID, LNAME);

DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
DROP (DEPT_ID, DEPT_NAME); -- ERROR

CREATE TABLE MMM();

CREATE TABLE TB1 (
    PK NUMBER PRIMARY,
    FK NUMBER REFERENCES FB1,
    COL1 NUMBER CHECK (COL1 > 0 AND PK >0)
);
    
ALTER TABLE TB1
DROP (PK); -- ERROR

-- 제약조건도 함께 삭제해야함
SELECT * FROM CONSTRAINT_EMP;
DESC CONSTRAINT_EMP;

-- 제약조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONSTRAINT_EMP';

-- 테이블 이름 바꾸기
RENAME CONSTRAINT_EMP TO CONST_EMP;

-- 제약조건 여러 개 삭제
ALTER TABLE CONST_EMP
DROP CONSTRAINT FKDID
DROP CONSTRAINT  FKMID;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONST_EMP';

-- NOT NULL 제약조건은 삭제가 아니라 변경임
-- NOT NULL 을 NULL 로 바꿈
ALTER TABLE CONST_EMP
MODIFY (ENAME NULL, ENO NULL);

-- USER_CONSTRAINTS 딕셔너리 : 컬럼 정보 없음
-- 컬럼별 제약조건을 관리하는 딕셔너리 : USER_CONS_COLUMNS
DESC USER_CONS_COLUMNS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME,
            DELETE_RULE, SEARCH_CONDITION
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING(TABLE_NAME, CONSTRAINT_NAME)
WHERE TABLE_NAME = 'CONST_EMP';

-- 제약조건 삭제 2
ALTER TABLE CONST_EMP
DROP PRIMARY KEY;

ALTER TABLE CONST_EMP
DROP UNIQUE (ENO);

-- 이름 바꾸기 : 테이블명, 컬럼명, 제약조건이름
-- 컬럼명 바꾸기
DESC DEPT_COPY;

ALTER TABLE DEPT_COPY
RENAME COLUMN DEPT_ID TO DID;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME,
            DELETE_RULE, SEARCH_CONDITION
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING(TABLE_NAME, CONSTRAINT_NAME)
WHERE TABLE_NAME = 'CONST_EMP';


ALTER TABLE CONST_EMP
RENAME CONSTRAINT CHK TO MRG_CHK;

-- 테이블명 바꾸기
ALTER TABLE DEPT_COPY RENAME TO DPCOPY;
RENAME DPCOPY TO DEPT_COPY;

-- 테이블 삭제하기 *****
DROP  TABLE DEPT_COPY;

DROP TABLE DEPARTMENT; -- ERROR
DROP TABLE DEPARTMENT CASCADE CONSTRAINTS;

ROLLBACK; -- DDL 구문은 복구 안 됨, DML 구문만 가능